[{"path":[]},{"path":"/articles/Application_average_401k.html","id":"getting-started","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Getting started","title":"Application 401(k) - average effects","text":"First, load packages set seed: Next, load data. use 401(k) data hdm package. However, can adapt following code chunk load suitable data choice. Just make sure call treatment D, covariates X, instrument Z. rest notebook run without modifications.","code":"if (!require(\"OutcomeWeights\")) install.packages(\"OutcomeWeights\", dependencies = TRUE); library(OutcomeWeights) if (!require(\"hdm\")) install.packages(\"hdm\", dependencies = TRUE); library(hdm) if (!require(\"grf\")) install.packages(\"grf\", dependencies = TRUE); library(grf) if (!require(\"cobalt\")) install.packages(\"cobalt\", dependencies = TRUE); library(cobalt) if (!require(\"tidyverse\")) install.packages(\"tidyverse\", dependencies = TRUE); library(tidyverse) if (!require(\"viridis\")) install.packages(\"viridis\", dependencies = TRUE); library(viridis) if (!require(\"gridExtra\")) install.packages(\"gridExtra\", dependencies = TRUE); library(gridExtra)  set.seed(1234) data(pension) # Find variable description if you type ?pension in console  # Treatment D = pension$p401 # Instrument Z = pension$e401 # Outcome Y = pension$net_tfa # Controls X = model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + marr + pira + twoearn, data = pension) var_nm = c(\"Age\",\"Benefit pension\",\"Education\",\"Family size\",\"Home owner\",\"Income\",\"Male\",\"Married\",\"IRA\",\"Two earners\") colnames(X) = var_nm"},{"path":"/articles/Application_average_401k.html","id":"run-double-ml","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Run Double ML","title":"Application 401(k) - average effects","text":"following run double ML default honest random forest (tuning increases running time without changing insights application). standard implementations currently allow extract outcome smoother matrices, OutcomeWeights package comes tailored internal implementation called dml_with_smoother(), used following.","code":""},{"path":"/articles/Application_average_401k.html","id":"folds","dir":"Articles","previous_headings":"1. Replication of paper results > Run Double ML","what":"2-folds","title":"Application 401(k) - average effects","text":"First, run estimators 2-fold cross-fitting:  Now, use get_outcome_weights() method extract outcome weights described paper. illustrate algebraic results provided paper indeed numerical equivalences approximations, check whether weights multiplied outcome vector reproduces conventionally generated point estimates.","code":"# 2 folds dml_2f = dml_with_smoother(Y,D,X,Z,                            n_cf_folds = 2) results_dml_2f = summary(dml_2f) ##           Estimate      SE      t         p     ## PLR        13876.4  1541.5 9.0019 < 2.2e-16 *** ## PLR-IV     12927.8  1909.3 6.7710 1.352e-11 *** ## AIPW-ATE   11681.1  1188.8 9.8258 < 2.2e-16 *** ## Wald-AIPW  11360.9  1652.3 6.8757 6.539e-12 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 plot(dml_2f) omega_dml_2f = get_outcome_weights(dml_2f) cat(\"ω'Y replicates point etimates?\",      all.equal(as.numeric(omega_dml_2f$omega %*% Y),       as.numeric(results_dml_2f[,1])     )) ## ω'Y replicates point etimates? TRUE"},{"path":"/articles/Application_average_401k.html","id":"fold","dir":"Articles","previous_headings":"1. Replication of paper results > Run Double ML","what":"5-fold","title":"Application 401(k) - average effects","text":"Run double ML also 5-fold cross-fitting:  extract weights confirm numerical equivalence:","code":"# 5 folds dml_5f = dml_with_smoother(Y,D,X,Z,                            n_cf_folds = 5) results_dml_5f = summary(dml_5f) ##           Estimate      SE      t         p     ## PLR        13915.5  1517.0 9.1728 < 2.2e-16 *** ## PLR-IV     13150.3  1898.5 6.9266 4.579e-12 *** ## AIPW-ATE   11530.5  1153.4 9.9972 < 2.2e-16 *** ## Wald-AIPW  11386.1  1634.5 6.9659 3.470e-12 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 plot(dml_5f) omega_dml_5f = get_outcome_weights(dml_5f) cat(\"ω'Y replicates point etimates?\",      all.equal(as.numeric(omega_dml_5f$omega %*% Y),       as.numeric(results_dml_5f[,1])     )) ## ω'Y replicates point etimates? TRUE"},{"path":"/articles/Application_average_401k.html","id":"check-covariate-balancing","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Check covariate balancing","title":"Application 401(k) - average effects","text":"use infrastructure cobalt package plot Standardized Mean Differences need flip sign untreated outcome weights make compatible package framework. achieved multiplying outcome weights 2 \\times D-1:     Create combined plot ends paper Figure 2:","code":"threshold = 0.1  create_love_plot = function(title, index) {   love.plot(     D ~ X,     weights = list(       \"2-fold\" = omega_dml_2f$omega[index, ] * (2*D-1),       \"5-fold\" = omega_dml_5f$omega[index, ] * (2*D-1)     ),     position = \"bottom\",     title = title,     thresholds = c(m = threshold),     var.order = \"unadjusted\",     binary = \"std\",     abs = TRUE,     line = TRUE,     colors = viridis(3), # color-blind-friendly     shapes = c(\"circle\", \"triangle\", \"diamond\")   ) }  # Now you can call this function for each plot: love_plot_plr = create_love_plot(\"PLR\", 1) love_plot_plriv = create_love_plot(\"PLR-IV\", 2) love_plot_aipw = create_love_plot(\"AIPW\", 3) love_plot_waipw = create_love_plot(\"Wald-AIPW\", 4) love_plot_plr love_plot_plriv love_plot_aipw love_plot_waipw figure2 = grid.arrange(   love_plot_plr, love_plot_aipw,   love_plot_plriv,love_plot_waipw,   nrow = 2 )"},{"path":[]},{"path":"/articles/Application_heterogeneous_401k.html","id":"getting-started","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Getting started","title":"Application 401(k) - heterogeneous effects","text":"First, load packages set seed: Next, load data. use 401(k) data hdm package. However, can adapt following code chunk load suitable data choice. Just make sure call treatment D, covariates X, instrument Z. rest notebook run without modifications.","code":"if (!require(\"OutcomeWeights\")) install.packages(\"OutcomeWeights\", dependencies = TRUE); library(OutcomeWeights) if (!require(\"hdm\")) install.packages(\"hdm\", dependencies = TRUE); library(hdm) if (!require(\"grf\")) install.packages(\"grf\", dependencies = TRUE); library(grf) if (!require(\"tidyverse\")) install.packages(\"tidyverse\", dependencies = TRUE); library(tidyverse) if (!require(\"viridis\")) install.packages(\"viridis\", dependencies = TRUE); library(viridis) if (!require(\"reshape2\")) install.packages(\"reshape2\", dependencies = TRUE); library(reshape2) if (!require(\"ggridges\")) install.packages(\"ggridges\", dependencies = TRUE); library(ggridges)  set.seed(1234) data(pension) # Find variable description if you type ?pension in console  # Treatment D = pension$p401 # Instrument Z = pension$e401 # Outcome Y = pension$net_tfa # Controls X = model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + marr + pira + twoearn, data = pension) var_nm = c(\"Age\",\"Benefit pension\",\"Education\",\"Family size\",\"Home owner\",\"Income\",\"Male\",\"Married\",\"IRA\",\"Two earners\") colnames(X) = var_nm"},{"path":"/articles/Application_heterogeneous_401k.html","id":"get-outcome-model-and-smoother-matrix","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Get outcome model and smoother matrix","title":"Application 401(k) - heterogeneous effects","text":"grf package save nuisance parameter models. Thus, retrieve required smoother matrices running causal_forest instrumental_forest . Therefore, estimate outcome nuisance model externally pass nuisance parameters later functions. described Section 5.2 paper, run default tuned version: , extract smoother matrix using get_forest_weights(): illustration, check random forest affine smoother summing smoother vectors checking whether sum one:","code":"### Externally calculate outcome nuisance rf_Y.hat_default = regression_forest(X,Y) rf_Y.hat_tuned = regression_forest(X,Y,tune.parameters = \"all\") Y.hat_default = predict(rf_Y.hat_default)$predictions Y.hat_tuned = predict(rf_Y.hat_tuned)$predictions # And get smoother matrices S_default = get_forest_weights(rf_Y.hat_default) S_tuned = get_forest_weights(rf_Y.hat_tuned) cat(\"RF affine smoother?\",      all.equal(rowSums(as.matrix(S_default)),       rep(1,length(Y))     )) ## RF affine smoother? TRUE"},{"path":"/articles/Application_heterogeneous_401k.html","id":"causal-forest","dir":"Articles","previous_headings":"1. Replication of paper results","what":"Causal forest","title":"Application 401(k) - heterogeneous effects","text":"Run causal forest externally estimated outcome nuisance: Get --bag CATEs: Use new get_outcome_weights() method, requires pass externally estimated outcome smoother matrix: Observe outcome weights recover grf package output: Now calculate absolute standardized mean differences plot CATE variables (Figure 3 paper):","code":"# Run CF with the pre-specified outcome nuisance  cf_default = causal_forest(X,Y,D,Y.hat=Y.hat_default) cf_tuned = causal_forest(X,Y,D,Y.hat=Y.hat_tuned,tune.parameters = \"all\") cates_default = predict(cf_default)$predictions cates_tuned = predict(cf_tuned)$predictions omega_cf_default = get_outcome_weights(cf_default, S = S_default) omega_cf_tuned = get_outcome_weights(cf_tuned, S = S_tuned) cat(\"ω'Y replicates CATE point estimates (default)?\",      all.equal(as.numeric(omega_cf_default$omega %*% Y),       as.numeric(cates_default)     )) ## ω'Y replicates CATE point estimates (default)? TRUE cat(\"\\nω'Y replicates CATE point estimates (tuned)?\",      all.equal(as.numeric(omega_cf_tuned$omega %*% Y),       as.numeric(cates_tuned)     )) ##  ## ω'Y replicates CATE point estimates (tuned)? TRUE cb_cate_default = standardized_mean_differences(X,D,omega_cf_default$omega,X) cb_cate_tuned = standardized_mean_differences(X,D,omega_cf_tuned$omega,X)  smd_default = t(abs(cb_cate_default[,3,])) smd_tuned = t(abs(cb_cate_tuned[,3,]))  # Melt the smd_default matrix to long format df_default_long = melt(smd_default) df_default_long$Group = \"smd_default\"  # Add a group identifier  # Melt the smd_tuned matrix to long format df_tuned_long = melt(smd_tuned) df_tuned_long$Group = \"smd_tuned\"  # Add a group identifier  # Combine the two data frames df_long = rbind(df_default_long, df_tuned_long)  # Rename the columns for clarity colnames(df_long) = c(\"Row\", \"Variable\", \"Value\", \"Group\")  # Create the ggplot figure3 = ggplot(df_long, aes(x = factor(Variable, levels = rev(unique(Variable))), y = Value, fill = Group)) +   geom_boxplot(position = position_dodge(width = 0.8)) +   labs(x = element_blank(), y = \"Absolute Standardized Mean Differences\") +   scale_fill_manual(values = viridis(2),                     name = element_blank(),                     labels = c(\"default\", \"tuned\")) +   theme_minimal() +   geom_hline(yintercept = 0, linetype = \"solid\", color = \"black\") +    coord_flip() figure3"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"high-level-motivation","dir":"Articles","previous_headings":"","what":"High-level motivation","title":"AIPW vs. RA and IPW","text":"Augmented inverse probability weighting (AIPW) .k.. doubly robust estimator .k.. Double ML interactive regression model attractive theoretical properties fits Double ML universe Chernozhukov et al. (2018). high level, properties arise AIPW leveraging outcome treatment information estimating average treatment effects. contrast (single ML) regression adjustment (RA) inverse probability weighting (IPW), leave treatment outcome information table, respectively. matter practice? outcome weights derived Knaus (2024) allow compare three estimators task familiar many practitioners: covariate balancing.","code":""},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"comparison-in-the-401k-data","dir":"Articles","previous_headings":"","what":"Comparison in the 401(k) data","title":"AIPW vs. RA and IPW","text":"First, load packages set seed. Next, load 401(k) data hdm package. However, can adapt following code chunk load suitable data choice. Just make sure call outcome Y, treatment D covariates X. rest notebook run without modifications.","code":"if (!require(\"hdm\")) install.packages(\"hdm\", dependencies = TRUE); library(hdm) if (!require(\"cobalt\")) install.packages(\"cobalt\", dependencies = TRUE); library(cobalt) if (!require(\"viridis\")) install.packages(\"viridis\", dependencies = TRUE); library(viridis) if (!require(\"OutcomeWeights\")) install.packages(\"OutcomeWeights\", dependencies = TRUE); library(OutcomeWeights)  set.seed(1234) data(pension) # Find variable description if you type ?pension in console  # Treatment D = pension$p401 # Outcome Y = pension$net_tfa # Controls X = model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + marr + pira + twoearn, data = pension) var_nm = c(\"Age\",\"Benefit pension\",\"Education\",\"Family size\",\"Home owner\",\"Income\",\"Male\",\"Married\",\"IRA\",\"Two earners\") colnames(X) = var_nm  N = length(Y)"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"aipw-and-its-weights","dir":"Articles","previous_headings":"Comparison in the 401(k) data","what":"AIPW and its weights","title":"AIPW vs. RA and IPW","text":"following run double ML honest random forest using OutcomeWeights internal implementation called dml_with_smoother() (packages store outcome smoothers required calculate outcome weights). Run AIPW:  Now, use get_outcome_weights() method extract outcome weights described paper.","code":"aipw = dml_with_smoother(Y,D,X,                         # progress=T, # uncomment to see progress                         # tune.parameters = \"all\",  # uncomment to tune hyperparameters                         estimators = \"AIPW_ATE\") summary(aipw) ##          Estimate      SE      t         p     ## AIPW-ATE  11553.5  1164.5 9.9216 < 2.2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 plot(aipw) omega_aipw = get_outcome_weights(aipw)"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"ipw-weights","dir":"Articles","previous_headings":"Comparison in the 401(k) data","what":"IPW weights","title":"AIPW vs. RA and IPW","text":"dml_with_smoother objects also store required components calculate canonical IPW weights.","code":"D.hat = aipw$NuPa.hat$predictions$D.hat omega_ipw = matrix(D / D.hat - (1-D) / (1-D.hat),1) / N"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"ra-weights","dir":"Articles","previous_headings":"Comparison in the 401(k) data","what":"RA weights","title":"AIPW vs. RA and IPW","text":"dml_with_smoother objects also store required components get RA weights rarely used easy obtain.","code":"omega_ra =  matrix(1, 1, N) %*% (aipw$NuPa.hat$smoothers$S.d1[1,,] - aipw$NuPa.hat$smoothers$S.d0[1,,]) / N"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"check-covariate-balancing","dir":"Articles","previous_headings":"Comparison in the 401(k) data","what":"Check covariate balancing","title":"AIPW vs. RA and IPW","text":"use infrastructure cobalt package plot Standardized Mean Differences. , need flip sign untreated outcome weights make compatible cobalt framework. achieved multiplying outcome weights 2 \\times D-1.  covariate balancing AIPW least good balancing IPW RA, cases substantially better. particular, failure RA balance “Benefit pension” striking.","code":"threshold = 0.1  love.plot(     D ~ X,     weights = list(       \"AIPW (Double ML)\" = as.numeric(omega_aipw$omega * (2*D-1)),       \"IPW (Single ML)\" = as.numeric(omega_ipw * (2*D-1)),       \"RA (Single ML)\" = as.numeric(omega_ra * (2*D-1))     ),     thresholds = c(m = threshold),     var.order = \"unadjusted\",     binary = \"std\",     abs = TRUE,     line = TRUE,     colors = viridis(4)   )"},{"path":"/articles/NB_OutcomeWeights_AIPW_401k.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"AIPW vs. RA and IPW","text":"serve small appetizer engage OutcomeWeights package. run data, please feel free share results via channel. particular, find qualitatively different behavior. Also please share issues GitHub.","code":""},{"path":[]},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"managing-expectations","dir":"Articles","previous_headings":"Setting the stage","what":"Managing expectations","title":"Theory in action","text":"notebook illustrates theoretical derivations Knaus (2024). keep everything simple possible meaning use cleaned readily available 401(k) data hdm package, includes treatment instrument use regression_forest() grf estimate nuisance parameters ML method build-function extract smoother weights hand-code two-fold cross-validation regression_forest() use nuisance parameters different estimators tune hyperparameters stick default setting consider causal/instrumental forest effect estimates one unit 9915 stick close possible paper notation However, code provides basis extend analysis different directions. end, click “Code” button top right “Download Rmd”. notebooks illustration. OutcomeWeights R package implements everything user friendly way.","code":""},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"load-packages-and-data","dir":"Articles","previous_headings":"Setting the stage","what":"Load packages and data","title":"Theory in action","text":"First, load relevant packages data Define useful quantities set seed:","code":"if (!require(\"cobalt\")) install.packages(\"cobalt\", dependencies = TRUE); library(cobalt) if (!require(\"grf\")) install.packages(\"grf\", dependencies = TRUE); library(grf) if (!require(\"hdm\")) install.packages(\"hdm\", dependencies = TRUE); library(hdm) if (!require(\"gridExtra\")) install.packages(\"gridExtra\", dependencies = TRUE); library(gridExtra) if (!require(\"tidyverse\")) install.packages(\"tidyverse\", dependencies = TRUE); library(tidyverse) if (!require(\"AER\")) install.packages(\"AER\", dependencies = TRUE); library(AER) data(pension) # Find variable description if you type ?pension in console # Treatment D = pension$p401 # Instrument Z = pension$e401 # Outcome Y = pension$net_tfa # Controls X = model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + marr + pira + twoearn, data = pension) colnames(X) = c(\"Age\",\"Benefit pension\",\"Education\",\"Family size\",\"Home owner\",\"Income\",\"Male\",\"Married\",\"IRA\",\"Two earners\") # Helpful variables N = length(Y) ones = matrix(1,N,1)  # Choose unit for which causal/instrumental forest weights should be calculated unit = 1  # Define number of folds for cross-fitting nfolds = 2  set.seed(1234)"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"one-function-to-calculate-them-all","dir":"Articles","previous_headings":"Setting the stage","what":"One function to calculate them all","title":"Theory in action","text":"Proposition 1 paper shows outcome weights vector can obtained general form \\boldsymbol{\\omega'} = (\\boldsymbol{\\tilde{Z}'\\tilde{D}})^{-1} \\boldsymbol{\\tilde{Z}'T} \\boldsymbol{\\tilde{Z}}, \\boldsymbol{\\tilde{D}} \\boldsymbol{T} pseudo-instrument, pseudo-treatment transformation matrix, respectively. motivates definition weight_maker(Dtilde,Ztilde,T_mat) function taking three generic inputs producing outcome weights vector: following, just need define three components respective estimators plug generic function obtain outcome weights.","code":"weight_maker = function(Dtilde,Ztilde,T_mat) {   omega = (t(Ztilde) %*% Dtilde)^(-1) %*% t(Ztilde) %*% T_mat   return(omega) }"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"estimate-all-nuisance-parameters-and-get-outcome-smoother-matrices","dir":"Articles","previous_headings":"Setting the stage","what":"Estimate all nuisance parameters and get outcome smoother matrices","title":"Theory in action","text":"Equation (8) paper shows nuisance parameters required estimators consideration. , estimate using honest random forest 2-fold cross-fitting. Additionally, extract relevant smoother matrices \\boldsymbol{S}, \\boldsymbol{S^d_0}, \\boldsymbol{S^d_1}, \\boldsymbol{S^z_0}, \\boldsymbol{S^z_1}. familiar smoothers, let’s observe produce exactly predictions original predict() functions: Also observe random forest affine smoother rows add exactly one: Finally, define different IPW weights later use:","code":"# Get fold number fold = sample(1:nfolds,N,replace=T)  # Initialize nuisance parameters Yhat = Yhatd0 = Yhatd1 = Yhatz0 = Yhatz1 =    Dhat = Dhatz0 = Dhatz1 = Zhat = rep(NA,N)  # Initialize smoother matrices S = Sd0 = Sd1 = Sz0 = Sz1 = matrix(0,N,N)  for (i in 1:nfolds){   # Calculate nuisance parameters and relevant smoother matrices   rf_Yhat = regression_forest(X[fold != i,],Y[fold != i])   Yhat[fold == i] = predict(rf_Yhat, X[fold == i,])$predictions   S[fold == i, fold != i] = as.matrix(get_forest_weights(rf_Yhat, X[fold == i,]))    rf_Yhatd0 = regression_forest(X[fold != i & D==0,],Y[fold != i & D==0])   Yhatd0[fold == i] = predict(rf_Yhatd0, X[fold == i,])$predictions   Sd0[fold == i, fold != i  & D==0] = as.matrix(get_forest_weights(rf_Yhatd0, X[fold == i,]))    rf_Yhatd1 = regression_forest(X[fold != i & D==1,],Y[fold != i & D==1])   Yhatd1[fold == i] = predict(rf_Yhatd1, X[fold == i,])$predictions   Sd1[fold == i, fold != i  & D==1] = as.matrix(get_forest_weights(rf_Yhatd1, X[fold == i,]))    rf_Yhatz0 = regression_forest(X[fold != i & Z==0,],Y[fold != i & Z==0])   Yhatz0[fold == i] = predict(rf_Yhatz0, X[fold == i,])$predictions   Sz0[fold == i, fold != i  & Z==0] = as.matrix(get_forest_weights(rf_Yhatz0, X[fold == i,]))      rf_Yhatz1 = regression_forest(X[fold != i & Z==1,],Y[fold != i & Z==1])   Yhatz1[fold == i] = predict(rf_Yhatz1, X[fold == i,])$predictions   Sz1[fold == i, fold != i  & Z==1] = as.matrix(get_forest_weights(rf_Yhatz1, X[fold == i,]))      rf_Dhat = regression_forest(X[fold != i,],D[fold != i])   Dhat[fold == i] = predict(rf_Dhat, X[fold == i,])$predictions      rf_Dhatz0 = regression_forest(X[fold != i & Z==0,],D[fold != i & Z==0])   Dhatz0[fold == i] = predict(rf_Dhatz0, X[fold == i,])$predictions      rf_Dhatz1 = regression_forest(X[fold != i & Z==1,],D[fold != i & Z==1])   Dhatz1[fold == i] = predict(rf_Dhatz1, X[fold == i,])$predictions      rf_Zhat = regression_forest(X[fold != i,],Z[fold != i])   Zhat[fold == i] = predict(rf_Zhat, X[fold == i,])$predictions } cat(\"Smoother matrices replicate predicted nuisance parameter?\",  all(   all.equal(as.numeric(S %*% Y), Yhat) == TRUE,   all.equal(as.numeric(Sd0 %*% Y), Yhatd0) == TRUE,   all.equal(as.numeric(Sd1 %*% Y), Yhatd1) == TRUE,   all.equal(as.numeric(Sz0 %*% Y), Yhatz0) == TRUE,   all.equal(as.numeric(Sz1 %*% Y), Yhatz1) == TRUE) ) ## Smoother matrices replicate predicted nuisance parameter? TRUE cat(\"Affine smoother matrices?\", all(   all.equal(as.numeric(ones),as.numeric(rowSums(S))) == TRUE,   all.equal(as.numeric(ones),as.numeric(rowSums(Sd0))) == TRUE,   all.equal(as.numeric(ones),as.numeric(rowSums(Sd1))) == TRUE,   all.equal(as.numeric(ones),as.numeric(rowSums(Sz0))) == TRUE,   all.equal(as.numeric(ones),as.numeric(rowSums(Sz1))) == TRUE) ) ## Affine smoother matrices? TRUE lambda1 = D / Dhat lambda0 = (1-D) / (1-Dhat) lambdaz1 = Z / Zhat lambdaz0 = (1-Z) / (1-Zhat)"},{"path":[]},{"path":[]},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"to-be-replicated","dir":"Articles","previous_headings":"Outcome weights of DML and GRF > Instrumental forest","what":"To be replicated","title":"Theory in action","text":", want replicate CLATE estimate unit 1. end, first run instrumental_forest() pre-defined nuisance parameters: estimated CLATE unit 1 6421.6180875, becomes number replicated:","code":"# Run IF with the pre-specified nuisance parameters ivf = instrumental_forest(X,Y,D,Z,Y.hat=Yhat,W.hat=Dhat,Z.hat=Zhat) # Get CLATEs  clates_if = predict(ivf)$predictions to_be_rep_if = clates_if[unit] to_be_rep_if ## [1] 6421.618"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"nearly-replication","dir":"Articles","previous_headings":"Outcome weights of DML and GRF > Instrumental forest","what":"Nearly replication","title":"Theory in action","text":"According main text paper, need following components \\boldsymbol{\\hat{R}} = \\boldsymbol{Z} - \\boldsymbol{\\hat{Z}}, \\quad \\boldsymbol{\\hat{V}} = \\boldsymbol{D} - \\boldsymbol{\\hat{D}}, \\quad \\boldsymbol{\\hat{U}} = \\boldsymbol{Y} - \\boldsymbol{\\hat{Y}}, \\quad \\alpha^{}(\\boldsymbol{x}) defined following Now define pseudo-variables transformation matrix: sanity check observe transformation matrix replicates pseudo-outcome: Now pass required components weight_maker() function estimates effect 6405.4799565, close identical number replicated:","code":"Uhat = Y - Yhat Vhat = D - Dhat Rhat = Z - Zhat alpha_if = get_forest_weights(ivf)[unit,] Ztilde_if = Rhat * alpha_if Dtilde_if = Vhat Ytilde_if = Uhat T_if = diag(N) - S cat(\"TY replicates pseudo-outcome?\",   all.equal(as.numeric( T_if %*% Y ), Uhat)) ## TY replicates pseudo-outcome? TRUE omega_if = weight_maker(Dtilde_if, Ztilde_if, T_if) repl_wo_const = omega_if %*% Y all.equal(as.numeric( repl_wo_const ), to_be_rep_if) ## [1] \"Mean relative difference: 0.002519426\""},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"exact-replication","dir":"Articles","previous_headings":"Outcome weights of DML and GRF > Instrumental forest","what":"Exact replication","title":"Theory in action","text":"noted Appendix .3.1, grf package applies additional constant requires adjust pseudo-instrument: Plugging new pseudo-instrument weight_maker() function creates outcome weights now perfectly replicate package output:","code":"# Create weighted residual maker matrix M1_inv = solve(t(ones) %*% diag(alpha_if) %*% ones) P1 = (ones %*% M1_inv) %*% (t(ones) %*% diag(alpha_if)) M1 = diag(N) - P1 # Get modified pseudo-instrument Ztilde_if = (M1 %*% Rhat) * alpha_if # Get if outcome weights omega_if = weight_maker(Dtilde_if, Ztilde_if, T_if)  cat(\"ω'Y replicates package output?\",all.equal(as.numeric( omega_if %*% Y ), to_be_rep_if)) ## ω'Y replicates package output? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"partially-linear-iv-regression","dir":"Articles","previous_headings":"Outcome weights of DML and GRF","what":"Partially linear IV regression","title":"Theory in action","text":"obtain standard partially linear IV regression, first solve canonical moment condition see value replicated: Compared , need pass different pseudo-instrument weight_maker replicate number:","code":"to_be_rep_plriv = mean(Rhat * Uhat) / mean(Rhat * Vhat) to_be_rep_plriv ## [1] 12570.88 # Modified pseudo-instrument Ztilde_plriv = Rhat * ones # Get outcome weights omega_plriv = weight_maker(Dtilde_if, Ztilde_plriv, T_if)  cat(\"ω'Y replicates moment based implentation?\",all.equal(as.numeric( omega_plriv %*% Y ), to_be_rep_plriv)) ## ω'Y replicates moment based implentation? TRUE"},{"path":[]},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"to-be-replicated-1","dir":"Articles","previous_headings":"Outcome weights of DML and GRF > Causal forest","what":"To be replicated","title":"Theory in action","text":", want replicate CATE estimate unit 1. end, first run causal_forest() pre-defined nuisance parameters: estimated CATE unit 1 5588.963803, becomes number replicated:","code":"cf = causal_forest(X,Y,D,Y.hat=Yhat,W.hat=Dhat) cates_cf = predict(cf)$predictions to_be_rep_cf = cates_cf[unit]"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"exact-replication-1","dir":"Articles","previous_headings":"Outcome weights of DML and GRF > Causal forest","what":"Exact replication","title":"Theory in action","text":"Causal forest works similar instrumental forest requires weight \\alpha^{cf}(\\boldsymbol{x}) enter pseudo-instrument: Plugging new pseudo-instrument weight_maker() function perfectly replicates package output:","code":"alpha_cf = get_forest_weights(cf)[unit,] M1_inv = solve(t(ones) %*% diag(alpha_cf) %*% ones) P1 = (ones %*% M1_inv) %*% (t(ones) %*% diag(alpha_cf)) M1 = diag(N) - P1 # Get pseudo-instrument Ztilde_cf = (M1 %*% Vhat) * alpha_cf # Get cf outcome weights omega_cf = weight_maker(Dtilde_if, Ztilde_cf, T_if)  cat(\"ω'Y replicates package output?\",     all.equal(as.numeric( omega_cf %*% Y ), to_be_rep_cf)) ## ω'Y replicates package output? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"partially-linear-regression","dir":"Articles","previous_headings":"Outcome weights of DML and GRF","what":"Partially linear regression","title":"Theory in action","text":"obtain standard partially linear regression, first solve canonical moment condition see value replicated: Compared CF, need pass different pseudo-instrument weight_maker() function replicate number:","code":"to_be_rep_plr = mean(Vhat * Uhat) / mean(Vhat * Vhat) to_be_rep_plr ## [1] 13576.51 # Modified pseudo-instrument Ztilde_plr = Vhat * ones # Get outcome weights omega_plr = weight_maker(Dtilde_if, Ztilde_plr, T_if)  cat(\"ω'Y replicates moment based implementation?\",     all.equal(as.numeric( omega_plr %*% Y ), to_be_rep_plr)) ## ω'Y replicates moment based implementation? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"augmented-inverse-probability-weighting","dir":"Articles","previous_headings":"Outcome weights of DML and GRF","what":"Augmented inverse probability weighting","title":"Theory in action","text":"AIPW uses large pseudo-outcome takes mean : replicate number outcome weights, need implement transformation matrix plug weight maker replicate number:","code":"Ytilde_aipw = Yhatd1 - Yhatd0 + lambda1 * (Y - Yhatd1) - lambda0 * (Y- Yhatd0) to_be_rep_aipw = mean(Ytilde_aipw) to_be_rep_aipw ## [1] 11521.92 # Taipw = Sd1 - Sd0 + diag(lambda1) %*% (diag(N) - Sd1) - diag(lambda0) %*% (diag(N) - Sd0) # slow T_aipw = Sd1 - Sd0 + lambda1 * (diag(N) - Sd1) - lambda0 * (diag(N) - Sd0) omega_aipw = weight_maker(ones, ones, T_aipw)  cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_aipw %*% Y ), to_be_rep_aipw)) ## ω'Y replicates standard implementation? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"wald-aipw","dir":"Articles","previous_headings":"Outcome weights of DML and GRF","what":"Wald AIPW","title":"Theory in action","text":"moment based representation ratio average treatment effects estimated AIPW: transformation matrix involved part also non-one pseudo-treatment:","code":"Dtilde_ivaipw = Dhatz1 - Dhatz0 + Z / Zhat * (D - Dhatz1) - (1 - Z) / (1 - Zhat) * (D - Dhatz0)  Ytilde_ivaipw = Yhatz1 - Yhatz0 + Z / Zhat * (Y - Yhatz1) - (1 - Z) / (1 - Zhat) * (Y - Yhatz0)  ITT_y = mean(Ytilde_ivaipw) ITT_d = mean(Dtilde_ivaipw)  to_be_rep_waipw = ITT_y / ITT_d to_be_rep_waipw ## [1] 11308.88 # T_waipw = Sz1 - Sz0 + diag(lambdaz1) %*% (diag(n) - Sz1) - diag(lambdaz0) %*% (diag(n) - Sz0) T_waipw = Sz1 - Sz0 + lambdaz1 * (diag(N) - Sz1) - lambdaz0 * (diag(N) - Sz0)  Dtilde_waipw = ones * ITT_d  omega_waipw = weight_maker(Dtilde_waipw, ones, T_waipw) cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_waipw %*% Y ), to_be_rep_waipw)) ## ω'Y replicates standard implementation? TRUE"},{"path":[]},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"tsls","dir":"Articles","previous_headings":"Outcome weights of special cases","what":"TSLS","title":"Theory in action","text":"can similarly extract outcome weights TSLS replicate standard implementation AER package: now use residuals produced residual maker matrix pseudo-instrument -treatment, residual maker matrix transformation matrix:","code":"tsls = ivreg(Y ~ D + X  | X + Z) summary(tsls) ##  ## Call: ## ivreg(formula = Y ~ D + X | X + Z) ##  ## Residuals: ##     Min      1Q  Median      3Q     Max  ## -507731  -16906   -2147   10266 1431531  ##  ## Coefficients: ##                    Estimate Std. Error t value Pr(>|t|)     ## (Intercept)      -3.239e+04  4.411e+03  -7.344 2.24e-13 *** ## D                 8.483e+03  1.799e+03   4.716 2.43e-06 *** ## XAge              6.248e+02  5.993e+01  10.425  < 2e-16 *** ## XBenefit pension -4.514e+03  1.344e+03  -3.360 0.000783 *** ## XEducation       -6.253e+02  2.282e+02  -2.740 0.006152 **  ## XFamily size     -1.067e+03  4.552e+02  -2.343 0.019150 *   ## XHome owner       1.063e+03  1.323e+03   0.804 0.421557     ## XIncome           9.283e-01  3.063e-02  30.309  < 2e-16 *** ## XMale            -1.028e+03  1.513e+03  -0.679 0.496987     ## XMarried          6.988e+02  1.814e+03   0.385 0.700108     ## XIRA              2.912e+04  1.467e+03  19.853  < 2e-16 *** ## XTwo earners     -1.933e+04  1.575e+03 -12.274  < 2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 55600 on 9903 degrees of freedom ## Multiple R-Squared: 0.2348,  Adjusted R-squared: 0.234  ## Wald test:   272 on 11 and 9903 DF,  p-value: < 2.2e-16 to_be_rep_tsls = tsls$coefficient[2] # Get residuals Ztilde_tsls = lm(Z ~ X)$residuals Dtilde_tsls = lm(D ~ X)$residuals  # Get projection matrix Xcons = model.matrix(~ X) PX = Xcons %*% solve(crossprod(Xcons)) %*% t(Xcons) # Get residual maker matrix MX = diag(N) - PX  # Create TSLS omega_tsls = weight_maker(Dtilde_tsls, Ztilde_tsls, MX)   cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_tsls %*% Y ), as.numeric(to_be_rep_tsls))) ## ω'Y replicates standard implementation? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"wald-estimator","dir":"Articles","previous_headings":"Outcome weights of special cases","what":"Wald estimator","title":"Theory in action","text":"Wald estimator replicated using residual maker matrix constant:","code":"# Get residuals Ztilde_wald = lm(Z ~ 1)$residuals Dtilde_wald = lm(D ~ 1)$residuals  # Get standard implementation wald = ivreg(Y ~ D | Z) to_be_rep_wald = wald$coefficient[2]  # Get projection and residual maker matrix of ones P1 = ones %*% solve(crossprod(ones)) %*% t(ones) M1 = diag(N) - P1  # Create TSLS omega_wald = weight_maker(Dtilde_wald, Ztilde_wald, M1)   cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_wald %*% Y ), as.numeric(to_be_rep_wald))) ## ω'Y replicates standard implementation? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"ols","dir":"Articles","previous_headings":"Outcome weights of special cases","what":"OLS","title":"Theory in action","text":"replicate OLS, can just recycle linear treatment residuals TSLS also pseudo-instrument:","code":"ols = lm(Y ~ D + X) to_be_rep_ols = ols$coefficient[2]  # Create OLS weights omega_ols = weight_maker(Dtilde_tsls, Dtilde_tsls, MX)   cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_ols %*% Y ), as.numeric(to_be_rep_ols))) ## ω'Y replicates standard implementation? TRUE"},{"path":"/articles/Theory_in_action_outcome_weights.html","id":"difference-in-means","dir":"Articles","previous_headings":"Outcome weights of special cases","what":"Difference in means","title":"Theory in action","text":"Finally, difference means estimator recovered recycling Wald residuals:","code":"dim = lm(Y ~ D) to_be_rep_dim = dim$coefficient[2]  # Create DiM weights omega_dim = weight_maker(Dtilde_wald, Dtilde_wald, M1)   cat(\"ω'Y replicates standard implementation?\",     all.equal(as.numeric( omega_dim %*% Y ), as.numeric(to_be_rep_dim))) ## ω'Y replicates standard implementation? TRUE"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael C. Knaus. Author, maintainer. Henri Pfleiderer. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Knaus M (2025). OutcomeWeights: Outcome Weights Treatment Effect Estimators. R package version 0.1.1.9000, https://github.com/MCKnaus/OutcomeWeights.","code":"@Manual{,   title = {OutcomeWeights: Outcome Weights of Treatment Effect Estimators},   author = {Michael C. Knaus},   year = {2025},   note = {R package version 0.1.1.9000},   url = {https://github.com/MCKnaus/OutcomeWeights}, }"},{"path":"/index.html","id":"outcomeweights-","dir":"","previous_headings":"","what":"Outcome Weights of Treatment Effect Estimators","title":"Outcome Weights of Treatment Effect Estimators","text":"R package calculates outcome weights Knaus (2024). use illustrated vignettes package website. core functionality get_outcome_weights() method implementing theoretical result Proposition 1 paper. shows outcome weights vector can obtained general form \\boldsymbol{\\omega'} = (\\boldsymbol{\\tilde{Z}'\\tilde{D}})^{-1} \\boldsymbol{\\tilde{Z}'T} \\boldsymbol{\\tilde{Z}}, \\boldsymbol{\\tilde{D}} \\boldsymbol{T} pseudo-instrument, pseudo-treatment transformation matrix, respectively. future compatible many estimated R objects possible. package can downloaded CRAN: package work progress. Find current state (suggestions welcome):","code":"install.packages(\"OutcomeWeights\")"},{"path":"/index.html","id":"in-progress","dir":"","previous_headings":"","what":"In progress","title":"Outcome Weights of Treatment Effect Estimators","text":"causal_forest() outcome weights CATE instrumental_forest() outcome weights CLATE causal_forest() outcome weights ATE average_treatment_effect() outcome weights average parameters compatible average_treatment_effect() Nuisance parameter estimation based honest random forest (regression_forest() grf package) dml_with_smoother() function runs PLR, PLR-IV, AIPW-ATE, Wald_AIPW compatible get_outcome_weights() Add Double ML estimators Add support smoothers","code":""},{"path":"/index.html","id":"envisioned-features","dir":"","previous_headings":"","what":"Envisioned features","title":"Outcome Weights of Treatment Effect Estimators","text":"Extract smoother matrices mlr3 available, possible Make smoother matrices mlr3 accessible within DoubleML Write get_outcome_weights() method DoubleML estimators Collect packages weights extracted implement development version available using devtools package:","code":"library(devtools) install_github(repo=\"MCKnaus/OutcomeWeights\")"},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Outcome Weights of Treatment Effect Estimators","text":"Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, arXiv:2411.11559","code":""},{"path":"/reference/dml_with_smoother.html","id":null,"dir":"Reference","previous_headings":"","what":"Double ML estimators with outcome smoothers — dml_with_smoother","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"Existing Double ML implementations general easily extract smoother matrices required compatible get_forest_weights() method. motivates yet another Double ML implementation.","code":""},{"path":"/reference/dml_with_smoother.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"","code":"dml_with_smoother(   Y,   D,   X,   Z = NULL,   estimators = c(\"PLR\", \"PLR_IV\", \"AIPW_ATE\", \"Wald_AIPW\"),   smoother = \"honest_forest\",   n_cf_folds = 5,   n_reps = 1,   ... )"},{"path":"/reference/dml_with_smoother.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"Y Numeric vector containing outcome variable. D Optional binary treatment variable. X Covariate matrix N rows p columns. Z Optional binary instrumental variable. estimators String (vector) indicating estimators run. Current menu: c(\"PLR\",\"PLR_IV\",\"AIPW_ATE\",\"Wald_AIPW\") smoother Indicate smoother used nuisance parameter estimation. Currently available option \"honest_forest\" grf package. n_cf_folds Number cross-fitting folds. Default 5. n_reps Number repetitions cross-fitting. Default 1. ... Options passed smoothers.","code":""},{"path":"/reference/dml_with_smoother.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"list three entries: results: list storing results, influence functions, score functions estimator NuPa.hat: list storing estimated nuisance parameters outcome smoother matrices","code":""},{"path":"/reference/dml_with_smoother.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"Chernozhukov, V., Chetverikov, D., Demirer, M., Duflo, E., Hansen, C., Newey, W., & Robins, J. (2018). Double/debiased machine learning treatment structural parameters. Econometrics Journal, 21(1), C1-C68. Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, https://arxiv.org/abs/2411.11559.","code":""},{"path":"/reference/dml_with_smoother.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Double ML estimators with outcome smoothers — dml_with_smoother","text":"","code":"# \\donttest{ # Sample from DGP borrowed from grf documentation n = 200 p = 5 X = matrix(rbinom(n * p, 1, 0.5), n, p) Z = rbinom(n, 1, 0.5) Q = rbinom(n, 1, 0.5) W = Q * Z tau =  X[, 1] / 2 Y = rowSums(X[, 1:3]) + tau * W + Q + rnorm(n)  # Run outcome regression and extract smoother matrix # Run DML and look at results dml = dml_with_smoother(Y,W,X,Z) results_dml = summary(dml) #>           Estimate      SE      t         p     #> PLR        0.93679 0.16871 5.5527 8.879e-08 *** #> PLR-IV     0.67135 0.31891 2.1052   0.03652 *   #> AIPW-ATE   0.98686 0.19805 4.9828 1.353e-06 *** #> Wald-AIPW  0.67755 0.34634 1.9563   0.05182 .   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 plot(dml)   # Get weights omega_dml = get_outcome_weights(dml)  # Observe that they perfectly replicate the original estimates all.equal(as.numeric(omega_dml$omega %*% Y),            as.numeric(as.numeric(results_dml[,1]))) #> [1] TRUE  # The weights can then be passed to the cobalt package for example. # }"},{"path":"/reference/get_outcome_weights.causal_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"Post-estimation command extract outcome weights causal forest implemented via causal_forest function grf package.","code":""},{"path":"/reference/get_outcome_weights.causal_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"","code":"# S3 method for class 'causal_forest' get_outcome_weights(   object,   ...,   S,   newdata = NULL,   S.tau = NULL,   target = \"CATE\",   checks = TRUE )"},{"path":"/reference/get_outcome_weights.causal_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"object object class causal_forest, .e. result running causal_forest. ... Pass potentially generic get_outcome_weights options. S smoother matrix reproducing outcome predictions used building instrumental_forest. Obtained calling get_forest_weights() regression_forest object producing outcome predictions. newdata Corresponds newdata option predict.causal_forest. NULL, --bag outcome weights, otherwise provided test data returned. S.tau Required target != \"CATE\", S.tau CATE smoother obtained running get_outcome_weights() target == \"CATE\". target Target parameter outcome weights extracted. Currently c(\"CATE\",\"ATE\") implemented. checks Default TRUE checks whether weights numerically replicate original estimates. set FALSE know need save computation time.","code":""},{"path":"/reference/get_outcome_weights.causal_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"get_outcome_weights object omega containing weights treat treatment","code":""},{"path":"/reference/get_outcome_weights.causal_forest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"Athey, S., Tibshirani, J., & Wager, S. (2019). Generalized random forest. Annals Statistics, 47(2), 1148-1178. Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, https://arxiv.org/abs/2411.11559.","code":""},{"path":"/reference/get_outcome_weights.causal_forest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outcome weights for the causal_forest function — get_outcome_weights.causal_forest","text":"","code":"# \\donttest{ # Sample from DGP borrowed from grf documentation n = 500 p = 10 X = matrix(rnorm(n * p), n, p) W = rbinom(n, 1, 0.5) Y = pmax(X[, 1], 0) * W + X[, 2] + pmin(X[, 3], 0) + rnorm(n)  # Run outcome regression and extract smoother matrix forest.Y = grf::regression_forest(X, Y) Y.hat = predict(forest.Y)$predictions outcome_smoother = grf::get_forest_weights(forest.Y)  # Run causal forest with external Y.hats c.forest = grf::causal_forest(X, Y, W, Y.hat = Y.hat)  # Predict on out-of-bag training samples. cate.oob = predict(c.forest)$predictions  # Predict using the forest. X.test = matrix(0, 101, p) X.test[, 1] = seq(-2, 2, length.out = 101) cate.test = predict(c.forest, X.test)$predictions  # Calculate outcome weights omega_oob = get_outcome_weights(c.forest,S = outcome_smoother) omega_test = get_outcome_weights(c.forest,S = outcome_smoother,newdata = X.test)  # Observe that they perfectly replicate the original CATEs all.equal(as.numeric(omega_oob$omega %*% Y),            as.numeric(cate.oob)) #> [1] TRUE all.equal(as.numeric(omega_test$omega %*% Y),            as.numeric(cate.test)) #> [1] TRUE  # Also the ATE estimates are perfectly replicated omega_ate = get_outcome_weights(c.forest,target = \"ATE\",                                  S = outcome_smoother,                                  S.tau = omega_oob$omega) all.equal(as.numeric(omega_ate$omega %*% Y),           as.numeric(grf::average_treatment_effect(c.forest, target.sample = \"all\")[1])) #> [1] TRUE  # The omega weights can be plugged into balancing packages like cobalt # }"},{"path":"/reference/get_outcome_weights.dml_with_smoother.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","title":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","text":"Post-estimation command extract outcome weights double ML run outcome smoother.","code":""},{"path":"/reference/get_outcome_weights.dml_with_smoother.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","text":"","code":"# S3 method for class 'dml_with_smoother' get_outcome_weights(object, ..., all_reps = FALSE)"},{"path":"/reference/get_outcome_weights.dml_with_smoother.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","text":"object object class dml_with_smoother, .e. result running dml_with_smoother. ... Pass potentially generic get_outcome_weights options. all_reps TRUE, outcomes weights repetitions passed. Default FALSE.","code":""},{"path":"/reference/get_outcome_weights.dml_with_smoother.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","text":"all_reps == FALSE: get_outcome_weights object all_reps == TRUE: additionally list omega_all_reps: list containing outcome weights repetition.","code":""},{"path":"/reference/get_outcome_weights.dml_with_smoother.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outcome weights for the dml_with_smoother function — get_outcome_weights.dml_with_smoother","text":"Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, https://arxiv.org/abs/2411.11559.","code":""},{"path":"/reference/get_outcome_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome weights method — get_outcome_weights","title":"Outcome weights method — get_outcome_weights","text":"generic method getting outcome weights. calculates outcome weights objects created packages. See get_outcome_weight.<compatible_fct> package documentation compatible functions.","code":""},{"path":"/reference/get_outcome_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome weights method — get_outcome_weights","text":"","code":"get_outcome_weights(object, ...)"},{"path":"/reference/get_outcome_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outcome weights method — get_outcome_weights","text":"object object, obtained packages. ... Additional arguments specific object class implementations. See documentation object requires additional arguments.","code":""},{"path":"/reference/get_outcome_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outcome weights method — get_outcome_weights","text":"list least components: omega: matrix (number point estimates x number estimation units) outcome weights treat: treatment indicator make compatible cobalt package","code":""},{"path":"/reference/get_outcome_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outcome weights method — get_outcome_weights","text":"Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, https://arxiv.org/abs/2411.11559.","code":""},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"Post-estimation command extract outcome weights instrumental forest implemented via instrumental_forest function grf package.","code":""},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"","code":"# S3 method for class 'instrumental_forest' get_outcome_weights(object, ..., S, newdata = NULL, checks = TRUE)"},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"object object class instrumental_forest, .e. result running instrumental_forest. ... Pass potentially generic get_outcome_weights options. S smoother matrix reproducing outcome predictions used building instrumental_forest. Obtained calling get_forest_weights() regression_forest object producing outcome predictions. newdata Corresponds newdata option predict.instrumental_forest. NULL, --bag outcome weights, otherwise provided test data returned. checks Default TRUE checks whether weights numerically replicate original estimates. set FALSE know want save computation time.","code":""},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"get_outcome_weights object omega containing weights treat treatment","code":""},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"Athey, S., Tibshirani, J., & Wager, S. (2019). Generalized random forest. Annals Statistics, 47(2), 1148-1178. Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, https://arxiv.org/abs/2411.11559.","code":""},{"path":"/reference/get_outcome_weights.instrumental_forest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outcome weights for the instrumental_forest function — get_outcome_weights.instrumental_forest","text":"","code":"# \\donttest{ # Sample from DGP borrowed from grf documentation n = 2000 p = 5 X = matrix(rbinom(n * p, 1, 0.5), n, p) Z = rbinom(n, 1, 0.5) Q = rbinom(n, 1, 0.5) W = Q * Z tau =  X[, 1] / 2 Y = rowSums(X[, 1:3]) + tau * W + Q + rnorm(n)  # Run outcome regression and extract smoother matrix forest.Y = grf::regression_forest(X, Y) Y.hat = predict(forest.Y)$predictions outcome_smoother = grf::get_forest_weights(forest.Y)  # Run instrumental forest with external Y.hats iv.forest = grf::instrumental_forest(X, Y, W, Z, Y.hat = Y.hat)  # Predict on out-of-bag training samples. iv.pred = predict(iv.forest)$predictions  omega_if = get_outcome_weights(iv.forest, S = outcome_smoother)  # Observe that they perfectly replicate the original CLATEs all.equal(as.numeric(omega_if$omega %*% Y),            as.numeric(iv.pred)) #> [1] TRUE  # }"},{"path":"/reference/NuPa_honest_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","title":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","text":"function estimates different nuisance parameters using honest random forest implementation 'grf' package","code":""},{"path":"/reference/NuPa_honest_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","text":"","code":"NuPa_honest_forest(   NuPa = c(\"Y.hat\", \"Y.hat.d\", \"Y.hat.z\", \"D.hat\", \"D.hat.z\", \"Z.hat\"),   X,   Y = NULL,   D = NULL,   Z = NULL,   n_cf_folds = 5,   n_reps = 1,   cluster = NULL,   progress = FALSE,   ... )"},{"path":"/reference/NuPa_honest_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","text":"NuPa String vector specifying nuisance parameters estimated. Currently supported: c(\"Y.hat\",\"Y.hat.d\",\"Y.hat.z\",\"D.hat\",\"D.hat.z\",\"Z.hat\") X Covariate matrix N rows p columns. Y Optional numeric vector containing outcome variable. D Optional binary treatment variable. Z Optional binary instrumental variable. n_cf_folds Number cross-fitting folds. Default 5. n_reps Number repetitions cross-fitting. Default 1. cluster Optional vector cluster variable cross-fitting account clusters. progress TRUE, progress nuisance parameter estimation reported. ... Options passed regression_forest.","code":""},{"path":"/reference/NuPa_honest_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","text":"List two lists. predictions contains requested nuisance parameters smoothers contains smoother matrices requested outcome nuisance parameters cf_mat Array dimension n_reps x N x n_cf_folds storing indicators representing folds used estimation.","code":""},{"path":"/reference/NuPa_honest_forest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nuisance parameter estimation via honest random forest — NuPa_honest_forest","text":"Wager, S., & Athey, S. (2018). Estimation inference heterogeneous treatment effects using random forests. Journal American Statistical Association, 113(523), 1228-1242.","code":""},{"path":"/reference/OutcomeWeights-package.html","id":null,"dir":"Reference","previous_headings":"","what":"OutcomeWeights: Outcome Weights of Treatment Effect Estimators — OutcomeWeights-package","title":"OutcomeWeights: Outcome Weights of Treatment Effect Estimators — OutcomeWeights-package","text":"Many treatment effect estimators can written weighted outcomes. weights established use cases like checking covariate balancing via packages like 'cobalt'. package takes original estimator objects outputs outcome weights. builds general framework Knaus (2024) doi:10.48550/arXiv.2411.11559 . version compatible 'grf' package provides internal implementation Double Machine Learning.","code":""},{"path":[]},{"path":"/reference/OutcomeWeights-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OutcomeWeights: Outcome Weights of Treatment Effect Estimators — OutcomeWeights-package","text":"Maintainer: Michael C. Knaus michael.knaus@uni-tuebingen.de (ORCID) contributors: Henri Pfleiderer henri.1999@web.de [contributor]","code":""},{"path":"/reference/pive_weight_maker.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","title":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","text":"generic function taking pseudo-instrument, pseudo-treatment transformation matrix inputs returning outcome weights","code":""},{"path":"/reference/pive_weight_maker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","text":"","code":"pive_weight_maker(Z.tilde, D.tilde, T_mat)"},{"path":"/reference/pive_weight_maker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","text":"Z.tilde Numeric vector pseudo-instrument outcomes. D.tilde Numeric vector pseudo-treatment. T_mat Transformation matrix","code":""},{"path":"/reference/pive_weight_maker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","text":"vector outcome weights.","code":""},{"path":"/reference/pive_weight_maker.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outcome weights maker for pseudo-IV estimators. — pive_weight_maker","text":"Knaus, M. C. (2024). Treatment effect estimators weighted outcomes, soon 'arXiv'.","code":""},{"path":"/reference/plot.dml_with_smoother.html","id":null,"dir":"Reference","previous_headings":"","what":"plot method for class dml_with_smoother — plot.dml_with_smoother","title":"plot method for class dml_with_smoother — plot.dml_with_smoother","text":"plot method class dml_with_smoother","code":""},{"path":"/reference/plot.dml_with_smoother.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot method for class dml_with_smoother — plot.dml_with_smoother","text":"","code":"# S3 method for class 'dml_with_smoother' plot(x, ..., alpha = 0.05, contrast = FALSE)"},{"path":"/reference/plot.dml_with_smoother.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot method for class dml_with_smoother — plot.dml_with_smoother","text":"x Object class dml_with_smoother. ... Pass generic plot options. alpha Significance level confidence intervals (default 0.05). contrast Shows differences coefficients.","code":""},{"path":"/reference/plot.dml_with_smoother.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot method for class dml_with_smoother — plot.dml_with_smoother","text":"ggplot point estimates confidence intervals.","code":""},{"path":"/reference/prep_cf_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates matrix of binary cross-fitting fold indicators (N x # cross-folds) — prep_cf_mat","title":"Creates matrix of binary cross-fitting fold indicators (N x # cross-folds) — prep_cf_mat","text":"Creates matrix binary cross-fitting fold indicators (N x # cross-folds)","code":""},{"path":"/reference/prep_cf_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates matrix of binary cross-fitting fold indicators (N x # cross-folds) — prep_cf_mat","text":"","code":"prep_cf_mat(n, cf, w_mat = NULL, cl = NULL)"},{"path":"/reference/prep_cf_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates matrix of binary cross-fitting fold indicators (N x # cross-folds) — prep_cf_mat","text":"n Number observations. cf Number cross-fitting folds. w_mat Optional logical matrix treatment indicators (N x T+1). specified, cross-fitting folds preserve treatment ratios full sample. cl Optional vector cluster variable cross-fitting account clusters.","code":""},{"path":"/reference/prep_cf_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates matrix of binary cross-fitting fold indicators (N x # cross-folds) — prep_cf_mat","text":"Logical matrix cross-fitting folds (N x # folds).","code":""},{"path":"/reference/standardized_mean_differences.html","id":null,"dir":"Reference","previous_headings":"","what":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","title":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","text":"Calculates standardized mean differences treated controls towards target means outcome weights matrix potentially many rows like CATEs.","code":""},{"path":"/reference/standardized_mean_differences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","text":"","code":"standardized_mean_differences(X, treat, omega, target = NULL)"},{"path":"/reference/standardized_mean_differences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","text":"X Covariate matrix N rows p columns. treat Binary treatment variable. omega Outcome weights matrix dimension number weight vectors balancing checked x number training units. target Optional matrix dimension number weight vectors balancing checked x p indicating target values covariates balanced towards. NULL, average X used target ATE.","code":""},{"path":"/reference/standardized_mean_differences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","text":"3D-array dimension p x 6 x number weight vectors balancing checked second dimension provides following quantities: \"Mean 0\": weighted control mean \"Mean 1\": weighted treated mean \"SMD balancing\": Standardized mean differences covariate balancing (Mean 1 - Mean 0) / sd(X) \"SMD targeting 0\": Standardized mean difference assess targeting control (Mean 0 - target) / sd(X) \"SMD targeting 1\": Standardized mean difference assess targeting treated (Mean 1 - target) / sd(X)","code":""},{"path":"/reference/standardized_mean_differences.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calls C++ implementation to calculate standardized mean differences. — standardized_mean_differences","text":"Rosenbaum, P. R., & Rubin, D. B. (1984). Reducing bias observational studies using subclassification propensity score. Journal American Statistical Association, 79 (387), 516–524.","code":""},{"path":"/reference/summary.dml_with_smoother.html","id":null,"dir":"Reference","previous_headings":"","what":"summary method for class dml_with_smoother — summary.dml_with_smoother","title":"summary method for class dml_with_smoother — summary.dml_with_smoother","text":"summary method class dml_with_smoother","code":""},{"path":"/reference/summary.dml_with_smoother.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary method for class dml_with_smoother — summary.dml_with_smoother","text":"","code":"# S3 method for class 'dml_with_smoother' summary(object, contrast = FALSE, quiet = FALSE, ...)"},{"path":"/reference/summary.dml_with_smoother.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary method for class dml_with_smoother — summary.dml_with_smoother","text":"object Object class dml_with_smoother. contrast Tests differences coefficients. quiet TRUE, results passed printed. ... arguments passed printCoefmat","code":""},{"path":"/reference/summary.dml_with_smoother.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary method for class dml_with_smoother — summary.dml_with_smoother","text":"Invisible matrix estimator(s) rows c(\"Estimate\",\"SE\",\"t\",\"p\") columns.","code":""},{"path":"/reference/summary.get_outcome_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"summary method for class outcome_weights — summary.get_outcome_weights","title":"summary method for class outcome_weights — summary.get_outcome_weights","text":"Calculates several summary measures potentially many outcome weights.","code":""},{"path":"/reference/summary.get_outcome_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary method for class outcome_weights — summary.get_outcome_weights","text":"","code":"# S3 method for class 'get_outcome_weights' summary(object, quiet = FALSE, digits = 4, epsilon = 1e-04, ...)"},{"path":"/reference/summary.get_outcome_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary method for class outcome_weights — summary.get_outcome_weights","text":"object get_outcome_weights object. quiet TRUE, results passed printed. digits Number digits displayed. Default 4. epsilon Threshold absolute values non-zero small values displayed < ... ... arguments passed printCoefmat","code":""},{"path":"/reference/summary.get_outcome_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary method for class outcome_weights — summary.get_outcome_weights","text":"3D-array dimension c(\"Control\",\"Treated\") x number point estimates x c(\"Minimum weight\",\"Maximum weight\",\"% Negative\",\"Sum largest 10%\",\"Sum weights\",\"Sum absolute weights\")","code":""},{"path":"/reference/summary.standardized_mean_differences.html","id":null,"dir":"Reference","previous_headings":"","what":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","title":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","text":"Calls C++ function quickly summarize potentially many standardized mean differences.","code":""},{"path":"/reference/summary.standardized_mean_differences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","text":"","code":"# S3 method for class 'standardized_mean_differences' summary(object, ...)"},{"path":"/reference/summary.standardized_mean_differences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","text":"object Object class standardized_mean_differences. ... arguments passed summary method.","code":""},{"path":"/reference/summary.standardized_mean_differences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","text":"3D-array dimension c(\"Maximum absolute SMD\",\"Mean absolute SMD\",\"Median absolute SMD\", / % absolute SMD > 20\", \"# / % absolute SMD > 10\",\"# / % absolute SMD > 5\") x c(\"Balancing\",\"Targeting\") x number weight vectors balancing checked","code":""},{"path":"/reference/summary.standardized_mean_differences.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"summary method for class standardized_mean_differences — summary.standardized_mean_differences","text":"Rosenbaum, P. R., & Rubin, D. B. (1984). Reducing bias observational studies using subclassification propensity score. Journal American Statistical Association, 79 (387), 516–524.","code":""},{"path":"/news/index.html","id":"outcomeweights-011","dir":"Changelog","previous_headings":"","what":"OutcomeWeights 0.1.1","title":"OutcomeWeights 0.1.1","text":"CRAN release: 2024-12-20 Fixed bug throwing error dml_with_smoother called without Z, regardless whether required input . Test added rule similar errors future","code":""},{"path":"/news/index.html","id":"outcomeweights-010","dir":"Changelog","previous_headings":"","what":"OutcomeWeights 0.1.0","title":"OutcomeWeights 0.1.0","text":"CRAN release: 2024-11-21 Initial CRAN submission.","code":""}]
